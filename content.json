{"pages":[{"title":"About Me","text":"EducationCarnegie Mellon University (2019 - Present) 15-213/18-213/15-513/14-513/18-613: Introduction to Computer Systems (ICS) Top 10 in Lab 1 - Lab 7 Rank 6/612 in Lab 1 - Data Lab Rank 9/621 in lab 2 - Bomb Lab Rank 7/598 in lab 3 - Attack Lab Rank 9/563 in lab 4 - Cache Lab Rank 2/537 in lab 5a - Malloc Lab Checkpoint Rank 2/546 in lab 5b - Malloc Lab Final Rank 3/541 in lab 6 - Shell Lab Rank 5/502 in lab 7a - Proxy Lab checkpoint Rank 5/531 in lab 7b - Proxy Lab Final 11-442/11-642: Search Engines Shanghai Jiao Tong University (2015 - 2019)SkillsPython, JavaScript, Solidity, Java, C/C++ Web &amp; Software development, Blockchain InternshipFull-stack developer@Intel ProjectsiDict-cmdcommand line version of iDict for macOs&amp;Windows&amp;Linux Configurable Color Theme iDict-weappA better English to Chinese Dictionary in Weapp. Autocorrection Tap &amp; Show Native &amp; Authoritative examples SnifferA Sniffer based on scapy and PyQt5. Colorful &amp; Responsive No packet loss under 100Mbps TCP Reassembly supported iReadingAn Effective English learning Android app. Tap &amp; Show at location Real time news feed Offline dictionary included","link":"/about/index.html"}],"posts":[{"title":"","text":"Nowadays, there are a lot of online coding platform, like LeetCode and CoderPad. Such platforms provide an IDE at the frontend for the user to write code. When they hit ‘Run’, the code will be automatically executed in remote server and have the result back to the user. RunCode is my prototype of such platform. In this article, we will build our own! DockerWe need docker to separate each user’s code and output file. By creating individual container for each code execution, we will not worry user’s malicious code like rm -rf / that will delete all the server. Besides, we can separate stdout so that users’ output won’t be interleaved. After installing docker, we will pull some alpine images for C/C++, Java, Python. I choose alpine because of its small size. For C&amp;C++, we only need to install g++ (it will install gcc as well). Creating the following Dockerfile. FROM alpine:3.10RUN apk add --no-cache g++ run docker build -t cpp . to build the image with tag cpp. For Java and Python, we will use the official alpine image docker pull python:3.7-alpinedocker pull java:alpine Build the CommandMemory RestrictionIt’s important that each user’s program will consume the memory from the host server indefinitely. We need to set memory restraint by using docker -m For example, limit the maximum memory usage is 64MB. docker -m 64M --memory-swap 64M However, if you see the warning No swap limit support. We need to change /etc/default/grub according to this solution. Especially for Google Cloud, we need to change /etc/default/grub.d/50-cloudimg-settings.cfg instead. After that, we will not see the warning. CleanUpusing docker --rm to clean up once done. TimeoutIt’s also important to set timeout so that malicious code (while True: pass) will not get executed indefinitely. However, it seems docker doesn’t support this natively. We may need to rely on command timeout to send SIGKILL when some time period is passed (5s). After that, we still need to clean up all the container resources, therefore we may need a random name for each container. So in case of timeout, we can use this name to kill this container first then combined with --rm, the container will be removed. Folder mappingFor each code execution, we need to create a new folder that contains the user input file, which will map(mount) it to the docker container by using docker -v docker -v /home/xinyi/random-folder:/code Therefore inside the folder /code of the container, it contains our input file. Compile &amp; RunPythonPython is the easiest to do, but we need to use -u to get the output docker run --rm -m 64M --memory-swap 64M --name cb8c6ecf-4afa-4fb0-9f46-a3a9dd982ca8 -v /runcode/input/cb8c6ecf-4afa-4fb0-9f46-a3a9dd982ca8:/code -w /code python:3.7-alpine python3 -u file.py C/C++docker run --rm -m 64M --memory-swap 64M --name 00854b7c-f768-406a-80cc-1851d2228920 -v /runcode/input/00854b7c-f768-406a-80cc-1851d2228920:/code -w /code cpp /bin/sh -c \"g++ -Wall file.cpp -o a &amp;&amp; ./a &gt;&amp;1 | tee\" I find only in this way we can get the multiprocessing output. JavaJava is the most tricky one, since we need to find the class with function main. Besides, if there is a public class, the filename should be exactly the same as the class name. Therefore, we need to do preprocessing on the input file and rename the file if possible. Regex /^\\s*public class\\s+([^\\s]+)/m is used to get the public class name, if any, rename the java file to the class name. Then using runJava.sh to compile and run. javac $1if [ $? -ne 0 ]; then # java compile error exit 1fifor classfile in *.class; do classname=${classfile%.*} #Execute fgrep with -q option to not display anything on stdout when the match is found if javap -public $classname | fgrep -q 'public static void main'; then java $classname \"$@\" exit 0; fidone Therefore, an additional read-only mapping for runJava.sh is necessary docker run --rm -m 64M --memory-swap 64M --name 00854b7c-f768-406a-80cc-1851d2228920 -v /runcode/input/00854b7c-f768-406a-80cc-1851d2228920:/code -w /code -v /runcode/input/runJava.sh:/code/runJava.sh:ro java:alpine sh -c \"./runJava.sh YourClass.java\" Error&amp;OutputWe can determine error, timeout or actual output from err, stdout and stderr like the following Node.js snippet. static async dockerRunAndCleanup(id, cmd) { return new Promise(((resolve, reject) =&gt; { exec(cmd, {timeout: this.TimeoutMs, killSignal: 'SIGKILL'}, (err, stdout, stderr) =&gt; { if (stderr) { if (stderr.startsWith(\"docker: Error response from daemon: OCI runtime\")) reject(\"Out of Memory 64MB\"); else reject(stderr); } if (err) { if (err.killed) { // timeout exec(`${this.dockerContainerKill} ${id}`); // kill the container resolve(stdout + `\\nTimeout after ${this.TimeoutMs}ms`); } else reject(err.message.split('\\n').slice(1).join('\\n')); } else resolve(stdout); }); }))}","link":"/2019/12/15/Build-Your-Own-Code-Runner/"},{"title":"Introduction of iDict-weapp","text":"A better English to Chinese Dictionary in Weapp. Features Autocorrection Responsive Autocorrection based on the distance of keyboard using weighted Levenshtein Single tap Single tap whatever word you like in the English Definition part and Sentence part will give you the explanation of the Lemma) of the word. You can choose to long tap or click the &gt; one the top-right corner to see the detail if necessary. Native &amp; Authoritative examples All the sentence examples are selected from famous dictionaries for the best reference. OALD (Oxford Advanced Learner’s Dictionary) CALD (Cambridge Advanced Learner’s Dictionary) LDOCE (Longman Dictionary of Contemporary English) CLED (Collins Learner’s English-Chinese Dictionary) Acknowledgement ECDICT for providing database of over 3 million words","link":"/2018/11/03/An-Introduction-to-iDict-Weapp/"},{"title":"Tutorial - Get Ready to Use IPFS Cluster","text":"IPFS has become one of the most popular ways to store your data in a decentralized way. This tutorial will demonstrate the basic usage of ipfs, ipfs-cluster and how to access it via axios in JavaScript. Perquisites Download ipfs,ipfs-cluster-service on all of your servers and ipfs-cluster-ctl on at least one of your servers on IPFS distributions. For me, I download them on all of my servers. Make them into PATH like ln * /usr/bin &amp;&amp; chmod a+x * make sure the following port is accessible on your server 8080 (ipfs get file) 9094 (ipfs cluster service RESTful API) 9096 (ipfs cluster service peer commuication) ConfigurationThe following steps should be done on all of your servers Init ipfs ipfs init (optional) Go to the .ipfs directory it generated and open config Change to &quot;Gateway&quot;: &quot;/ip4/0.0.0.0/tcp/8080&quot; so that we can get the file from http://ip:8080/hash Init ipfs-cluster ipfs-cluster-service init Go to the .ipfs-cluster directory it generated and open service.json Make sure every server has the same secret (optional) Go to the .ipfs directory it generated and open config Change to &quot;http_listen_multiaddress&quot; in restapi to &quot;/ip4/0.0.0.0/tcp/9094&quot; so that we can add&amp;pin the file into the whole cluster from http://ip:9094 Start DaemonThe following steps can be optimized to use superviser Start ipfs daemon on every server ipfs daemon Start ipfs-cluster-service daemon on first server ipfs-cluster-service daemon Start ipfs-cluster-service daemon on other servers by bootstrap ipfs-cluster-service daemon --bootstrap /ip4/[ip-of-first-server]/tcp/9096/ipfs/[cluster-service-id] cluster-service-id can be inferred from cluster.id from service.json or logs of ipfs-cluster-service daemon on first server. e.g ipfs-cluster-service daemon --bootstrap /ip4/12.34.56.78/tcp/9096/ipfs/QmVw41GTKr76Xw2zAgXn1ic98nZfYj1DPd7VJPku4q1oW9 Right now, they should be connected! Access cluster by axios add&amp;pin files on one of the server in the cluster POST [ip]:9094/add (request content-type must bemultipart/form-data ) get files from all of the server in the cluster GET [ip]:8080/ipfs/[CID] Here is the axios example in Vue to upload a binary file (Buffer) in one peer and access it from another in frontend. let buffer = Buffer.from[1,2,3];let bodyFormData = new FormData();const blob = new Blob([new Uint8Array(buffer)]);bodyFormData.set('file', blob);let that = this;this.$axios({ method: 'post', url: 'http://12.34.56.78:9094/add', data: bodyFormData, config: { headers: {'Content-Type': 'multipart/form-data'}, }}).then(response =&gt; { const cid = response.data.cid; that.$axios.get(`http://23.45.67.89/ipfs/${cid}`, { responseType: 'arraybuffer' }).then(x =&gt; { const downloaded = Buffer.from(x.data); console.log(downloaded) })})","link":"/2019/03/03/Get-Ready-to-Use-IPFS-Cluster/"},{"title":"Try iDict in Command Line","text":"command line version of iDict for macOs&amp;Windows&amp;Linux 适用macOs, Windows(64位)和Linux的命令行版本iDict英语词典,包含330W词库以及来自权威词典的双语例句。 轻量级,包含所有依赖的可执行文件,下载即用。 同时推荐微信小程序版本，在移动端获取极佳体验 Install请去Release页面下载对应的可执行文件 Linux wget https://github.com/AntiSomnus/iDict-cmd/releases/download/[latest-release-number]/idict_linux &amp;&amp; chmod a+x idict_linux Make sure to change [latest-release-number] to the number of release, e.g 2.0 Or you can just go to Release page to download the latest version. add the location to the path ln -s /location/to/idict_linux /usr/local/bin/idict idict welcome idict welcome -d idict welcome -d 3 Windows Just go to Release page to download the latest version. add the location to the path idict welcome idict welcome -d idict welcome -d 3 macOs macOs上使用需要brew安装openssl wget https://github.com/AntiSomnus/iDict-cmd/releases/download/[latest-release-number]/idict_macos &amp;&amp; chmod a+x idict_macos Make sure to change [latest-release-number] to the number of release, e.g 2.0 Or you can just go to Release page to download the latest version. make sure you have openssl installed brew install openssl add the location to the path ln -s /location/to/idict_macos /usr/local/bin/idict idict welcome idict welcome -d idict welcome -d 3 Usageidict word [-d|--detail [max-sentences-per-dict] ]word the word you want to query 你想要查询的单词,默认不包含例句-d | --detail get the detailed info of the word 获取单词详细释义，包含例句 max-sentences-per-dict(default=2) 显示的例句数量，默认为2 Exampleidict welcomeidict welcome -didict welcome -d 1 Color (Beta in win64_python version)修改color.ini即可修改颜色 New python version will give you the flexibility to change color configuration. Just change the color.ini in the folder of win64_python Release The color table is belowBLACK = 30RED = 31GREEN = 32YELLOW = 33BLUE = 34MAGENTA = 35CYAN = 36WHITE = 37RESET = 39LIGHTBLACK = 90LIGHTRED = 91LIGHTGREEN = 92LIGHTYELLOW = 93LIGHTBLUE = 94LIGHTMAGENTA = 95LIGHTCYAN = 96LIGHTWHITE = 97 default color configuration is[COLOR]word_color = 91section_color = 92hint_color = 93text_color = 97source_color = 90 Sentences from news (Beta in win64_python version)可以获得来自国外权威新闻媒体对于该单词的用法，在win64_python版本中使用-n即可开启，如idict test -n或idict test -n -d New feature that provides sentences from news by the api of vocabulary.com Compile on your own Linux g++ -Os -s -m64 -std=c++14 idict_linux.cpp -o idict -Wl,-static -lssl -lcrypto -Wl,-Bdynamic -ldl if you have the error of undefined reference to 'pthread_getspecific', you might need to add -pthread g++ -Os -s -m64 -std=c++14 idict_linux.cpp -o idict -Wl,-static -lssl -lcrypto -Wl,-Bdynamic -ldl -pthread Windows g++ idict_win.cpp -o idict -Os -s -m64 -std=c++14 -static-libgcc -static-libstdc++ -Wl,-Bstatic,--whole-archive -lwinpthread -Wl,--no-whole-archive -Wl,-Bstatic -lssl -lcrypto -Wl,-Bdynamic -lws2_32 macOs In order to use it properly, you must install openssl from brew first. brew install openssl For compilers to find openssl you must set: export LD_LIBRARY_PATH=/usr/local/opt/openssl/lib:\"${LD_LIBRARY_PATH}\"export CPATH=/usr/local/opt/openssl/include:\"${CPATH}\" https://github.com/AntiSomnus/iDict-cmd.git cd iDict-cmd Compile g++ -Os -m64 -std=c++14 idict_linux.cpp -o idict -lssl -lcrypto","link":"/2018/11/03/Try-iDict-in-Command-Line/"},{"title":"Tutorial - Using Protobuf in Flutter","text":"Recently, I have working on Futter project. However, I have found it quite difficult to install the Dart protobuf plugin on Linux. Here is my tutorial for you to save your time. Install Dart Following the instruction here to install Dart Dart SDK For me, I just download the deb file and install it. sudo dpkg -i dart_2.1.0-1_amd64.deb After that we can use dart in terminal, but we cannot find pub . The reason is beacuse it is located in usr/lib/dart/bin Therefore, we’d better change the PATH permanently. Change the PATH permanently for pub gedit ~/.profile Then add the following to the end of .profile export PATH=$PATH:/usr/lib/dart/bin Logout and login again to let the modification take effect. Type pub in terminal, we will see it works. Install protoc The simplest way is to use to precompiled protoc binary and put it into PATH Protobuf Release For me, I download the protoc-3.6.1-osx-x86_64.zip. Unzip it, and put protoc binary to /usr/bin Then, we type protoc in terminal, we will see it works. Install Dart protoc_plugin In the terminal, type pub global activate protoc_plugin Right now, I’m in China. For reasons known to all, I have to use the mirror export PUB_HOSTED_URL=https://pub.flutter-io.cn However, it is installed in $HOME/.pub-cache/bin. We’d better make it into PATH again. Using the same way in ~/.profile Now, the last line looks like export PATH=$PATH:/usr/lib/dart/bin:$HOME/.pub-cache/bin You need to logout and login to again to take effect. Compile from .proto file Finally, we can compile .proto file to .dart file. For me, I just go to the directory containing the .proto file, using the command below, and it will generate the .dart file(s) you need. You can copy them to your flutter project protc --dart_out=. ./YourFile.proto Install protobuf runtime library Don’t forget to install the runtime library by adding protobuf: ^0.11.0 in your dependency part of pubspec.yaml That’s it! Hope it will save your time to build your flutter project with awesome protobuf!","link":"/2019/01/12/Using-Protobuf-In-Flutter/"},{"title":"Verify IPFS Multihash","text":"IPFS has a unique way of identifying the data you store with multihash. For example, using ipfs add an_image.png will actually return a mutlihash which you can use to retrieve the file. However, it seems plausible for the front-end (JavaScript) to have the ability to verify it after the content is downloaded. Don’t worry, you are about to grasp it! Decode MultihashMultihash actually contains the hash method we use and the hash digest output of the content, encoded by base58. Using multihashes library will make you understand it. In IPFS, the hash method is always sha2-256 right now. The following class CID will help you convert between sha256 hash and multihash. const mh = require('multihashes');class CID { /** * convert IPFS multihash to sha2-256 hash string * @param {string} multihash * @returns {string} sha2-256 hash string starting with 0x */ static toHash(multihash) { return '0x' + mh.decode(mh.fromB58String(multihash)).digest.toString('hex') } /** * convert sha2-256 hash string to IPFS multihash * @param {string} str * @returns {string} IPFS multihash starting with Qm */ static fromHash(str) { str = str.startsWith('0x') ? str.slice(2) : str; return mh.toB58String(mh.encode(Buffer.from(str, 'hex'), 'sha2-256')) }} The input of SHA256However, the input of SHA256 is the content alone, it’s actually wrapped by protobuf. To get a deep understanding of it, we can do a simple test. create a file containes ipfs-multihash and add it to IPFS echo ipfs-multihash &gt; test.txt | ipfs add test.txt Its multihash CID will be QmfQj4DUWEudeFdWKVzPaTbYimdYzsp14DZX1VLV1BbtdN. Get the SHA256 hash from the multihash. console.log(CID.toHash(\"QmfQj4DUWEudeFdWKVzPaTbYimdYzsp14DZX1VLV1BbtdN\")); The result will be 0xfda1ea739791f6784b13590d4be03f6a6dad136eb3ac7615522ad0d910f66cd9 hash the file ipfs get QmfQj4DUWEudeFdWKVzPaTbYimdYzsp14DZX1VLV1BbtdN \\&amp;&amp; shasum -a 256 &lt; QmfQj4DUWEudeFdWKVzPaTbYimdYzsp14DZX1VLV1BbtdN The SHA256 result is b41a3a2a90e84bf773e03a8bd0d0090f5beb42332a6faaa8718db083ebb130dd, which clearly is not fda1ea739791f6784b13590d4be03f6a6dad136eb3ac7615522ad0d910f66cd9 Using block get instead ipfs block get QmfQj4DUWEudeFdWKVzPaTbYimdYzsp14DZX1VLV1BbtdN &gt; block.tmp \\&amp;&amp; shasum -a 256 &lt; block.tmp Finally, the SHA256 result is fda1ea739791f6784b13590d4be03f6a6dad136eb3ac7615522ad0d910f66cd9. So what is the content of block get anyway? Using protoc to see what actually happens protoc --decode_raw &lt; block.tmp The result is actually great 1 { 1: 2 2: \"ipfs-multihash\\n\" 3: 15} According to how-recreate-a-hash-digest-of-a-multihash-in-ipfs, we know it contains Type, Data and fileSize. A simplified and working example is here: syntax = \"proto3\";message PBNode { bytes Data = 1;}message PBLink { bytes Hash = 1; string Name = 2; uint64 Tsize = 3;}message Data { enum DataType { Raw = 0; Directory = 1; File = 2; Metadata = 3; Symlink = 4; HAMTShard = 5; } DataType Type = 1; bytes Data = 2;} Full exampleconst mh = require('multihashes');const axios = require('axios');const crypto = require('crypto');const protobuf = require(\"protobufjs\");const IPFS = protobuf.loadSync('./ipfs.proto').lookupType('PBNode');class CID { /** * convert IPFS multihash to sha2-256 hash string * @param {string} multihash * @param {boolean} prefix * @returns {string} sha2-256 hash string starting with 0x */ static toHash(multihash, prefix = false) { return prefix ? '0x' : '' + mh.decode(mh.fromB58String(multihash)).digest.toString('hex') } /** * convert sha2-256 hash string to IPFS multihash * @param {string} str * @returns {string} IPFS multihash starting with Qm */ static fromHash(str) { str = str.startsWith('0x') ? str.slice(2) : str; return mh.toB58String(mh.encode(Buffer.from(str, 'hex'), 'sha2-256')) } /** * hash the buffer and get the SHA256 result compatible with IPFS multihash * @param {Buffer} buf * @returns {string} */ static hash(buf) { const r = IPFS.encode({ Data: { Type: 2, Data: buf, filesize: buf.length } }).finish(); return crypto.createHash('sha256').update(r).digest('hex'); }}async function ipfsGet(cid) { const x = await axios.get(`http://your.address.xxx/ipfs/${cid}`, { responseType: 'arraybuffer' }); return Buffer.from(x.data);}const r = \"QmfQj4DUWEudeFdWKVzPaTbYimdYzsp14DZX1VLV1BbtdN\";const hashFromCID = CID.toHash(r);console.log(hashFromCID);ipfsGet(r).then(buf =&gt; { const hashCalculated = CID.hash(buf); console.log(hashCalculated); console.log(hashCalculated === hashFromCID); console.log(CID.fromHash(hashCalculated) === r)});module.exports = CID;","link":"/2019/04/11/Verify-IPFS-Multihash/"}],"tags":[{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"iDict","slug":"iDict","link":"/tags/iDict/"},{"name":"IPFS","slug":"IPFS","link":"/tags/IPFS/"},{"name":"Decentralized","slug":"Decentralized","link":"/tags/Decentralized/"},{"name":"Protobuf","slug":"Protobuf","link":"/tags/Protobuf/"},{"name":"Security","slug":"Security","link":"/tags/Security/"}],"categories":[{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"iDict","slug":"iDict","link":"/categories/iDict/"},{"name":"IPFS","slug":"IPFS","link":"/categories/IPFS/"},{"name":"Weapp","slug":"iDict/Weapp","link":"/categories/iDict/Weapp/"},{"name":"cmd","slug":"iDict/cmd","link":"/categories/iDict/cmd/"},{"name":"Flutter","slug":"Flutter","link":"/categories/Flutter/"},{"name":"Protobuf","slug":"Flutter/Protobuf","link":"/categories/Flutter/Protobuf/"}]}